<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VibeCheck</title>
    <style>
      :root {
        --bg: #101018;
        --glow: transparent;
        --vibe-color: #8aa7ff;
        --pulse: 1;
        --card: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.7);
        --border: rgba(255, 255, 255, 0.16);
      }

      * { box-sizing: border-box; }

      @keyframes vibeGlow {
        0%, 100% { opacity: 0.5; transform: scale(1); }
        50%      { opacity: 0.85; transform: scale(1.08); }
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        color: var(--text);
        background: var(--bg);
        transition: background 1.2s ease;
        overflow-x: hidden;
      }

      body::before {
        content: '';
        position: fixed;
        inset: -40%;
        z-index: -1;
        background: var(--glow, transparent);
        filter: blur(120px);
        animation: vibeGlow 6s ease-in-out infinite;
        pointer-events: none;
      }

      #visualizer {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
      }

      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 28px 18px 60px;
        position: relative;
        z-index: 1;
        transform: scale(var(--pulse, 1));
        transition: transform 180ms ease-out;
      }

      h1 {
        margin: 0 0 14px;
        font-size: 28px;
        letter-spacing: 0.2px;
      }

      .sub {
        margin: 0 0 22px;
        color: var(--muted);
        line-height: 1.4;
      }

      .row {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 18px;
      }

      button {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.10);
        color: var(--text);
        padding: 10px 14px;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .pill {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        padding: 8px 10px;
        border-radius: 999px;
        color: var(--muted);
        font-size: 13px;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
      }

      @media (min-width: 860px) {
        .grid {
          grid-template-columns: 1fr 1fr;
        }
      }

      .card {
        border: 1px solid var(--border);
        background: var(--card);
        border-radius: 14px;
        padding: 14px 14px 16px;
      }

      .label {
        font-size: 13px;
        color: var(--muted);
        margin: 0 0 8px;
      }

      .value {
        margin: 0;
        font-size: 16px;
        line-height: 1.4;
      }

      .list {
        margin: 0;
        padding-left: 18px;
        color: var(--text);
      }

      .list li {
        margin: 6px 0;
        display: flex;
        align-items: baseline;
        gap: 8px;
        flex-wrap: wrap;
      }

      a { color: var(--text); }
      a:hover { opacity: 0.9; }

      .yt-link {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        font-size: 12px;
        color: #ff4e45;
        text-decoration: none;
        opacity: 0.85;
        white-space: nowrap;
      }
      .yt-link:hover { opacity: 1; }

      .err {
        margin-top: 14px;
        color: #ffd1d1;
        background: rgba(255, 0, 0, 0.12);
        border: 1px solid rgba(255, 0, 0, 0.28);
        padding: 10px 12px;
        border-radius: 12px;
        display: none;
        white-space: pre-wrap;
      }

      .hint {
        color: var(--muted);
        font-size: 13px;
        margin-top: 8px;
      }

      /* ── Constellation ─────────────────────────────── */
      #constellationSection {
        display: none;                /* shown after first identify */
        margin-top: 24px;
      }
      #constellationSection.active { display: block; }

      .constellation-header {
        display: flex;
        align-items: center;
        gap: 14px;
        flex-wrap: wrap;
        margin-bottom: 10px;
      }

      .constellation-header h2 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.3px;
      }

      .slider-group {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: var(--muted);
      }

      .slider-group input[type="range"] {
        width: 110px;
        accent-color: var(--vibe-color, #8aa7ff);
      }

      #constellationWrap {
        position: relative;
        width: 100%;
        height: 520px;
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0,0,0,0.35);
        cursor: grab;
      }
      #constellationWrap:active { cursor: grabbing; }
      #constellationWrap.loading { cursor: wait; }

      #constellationCanvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #constellationTooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(20,20,30,0.92);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 13px;
        color: var(--text);
        white-space: nowrap;
        display: none;
        z-index: 10;
      }

      .constellation-legend {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.5;
      }
    </style>
  </head>
  <body>
    <canvas id="visualizer"></canvas>
    <div class="wrap">
      <h1>VibeCheck</h1>
      <p class="sub">Record 10 seconds → identify the track → get similar songs + top tags → update the mood board.</p>

      <div class="row">
        <button id="recordBtn">Record (10s)</button>
        <span id="status" class="pill">Idle</span>
        <span id="tagsPill" class="pill" style="display:none;"></span>
      </div>

      <div class="grid">
        <div class="card">
          <p class="label">Identified Song</p>
          <p id="identified" class="value">—</p>
          <p class="hint">Tip: allow microphone permission when prompted.</p>
        </div>

        <div class="card">
          <p class="label">Recommended Tracks</p>
          <ol id="recs" class="list"></ol>
        </div>
      </div>

      <div id="error" class="err"></div>

      <!-- ── Constellation ─────────────────────────────── -->
      <div id="constellationSection">
        <div class="constellation-header">
          <h2>Music Constellation</h2>
          <div class="slider-group">
            <label for="gravitySlider">Gravity</label>
            <input id="gravitySlider" type="range" min="5" max="300" value="80" />
          </div>
          <button id="resetConstBtn" style="font-size:13px;padding:6px 10px;">Reset Map</button>
        </div>
        <div id="constellationWrap">
          <canvas id="constellationCanvas"></canvas>
          <div id="constellationTooltip"></div>
        </div>
        <p class="constellation-legend">
          Click a star to expand&nbsp;·&nbsp;Bigger star = more plays&nbsp;·&nbsp;Shorter line = more similar&nbsp;·&nbsp;Drag to pan&nbsp;·&nbsp;Scroll to zoom
        </p>
      </div>
    </div>

    <script>
      const recordBtn = document.getElementById('recordBtn');
      const statusEl = document.getElementById('status');
      const identifiedEl = document.getElementById('identified');
      const recsEl = document.getElementById('recs');
      const errorEl = document.getElementById('error');
      const tagsPill = document.getElementById('tagsPill');
      const canvas = document.getElementById('visualizer');
      const ctx = canvas.getContext('2d');

      let audioCtx = null;
      let analyser = null;
      let dataArray = null;
      let animationId = null;
      let recordingActive = false;

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function showError(message) {
        errorEl.style.display = 'block';
        errorEl.textContent = message;
      }

      function clearError() {
        errorEl.style.display = 'none';
        errorEl.textContent = '';
      }

      function resizeCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function getVibeColor() {
        const color = getComputedStyle(document.documentElement).getPropertyValue('--vibe-color').trim();
        return color || '#8aa7ff';
      }

      function startVisualizer(stream) {
        if (recordingActive) return;

        recordingActive = true;
        resizeCanvas();

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.82;
        const source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        animationId = requestAnimationFrame(animate);
      }

      function stopVisualizer() {
        recordingActive = false;
        if (animationId) cancelAnimationFrame(animationId);
        animationId = null;
        if (audioCtx) {
          audioCtx.close();
          audioCtx = null;
        }
        analyser = null;
        dataArray = null;
        document.documentElement.style.setProperty('--pulse', '1');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function animate(t) {
        if (!recordingActive || !analyser || !dataArray) return;

        analyser.getByteFrequencyData(dataArray);

        const len = dataArray.length;
        let sum = 0;
        for (let i = 0; i < len; i += 1) sum += dataArray[i];
        const avg = sum / len;

        const bassCount = Math.max(6, Math.floor(len * 0.12));
        const trebleStart = Math.floor(len * 0.75);
        let bassSum = 0;
        let trebleSum = 0;

        for (let i = 0; i < bassCount; i += 1) bassSum += dataArray[i];
        for (let i = trebleStart; i < len; i += 1) trebleSum += dataArray[i];

        const bassAvg = bassSum / bassCount;
        const trebleAvg = trebleSum / Math.max(1, len - trebleStart);

        const avgNorm = avg / 255;
        const bassNorm = bassAvg / 255;
        const trebleNorm = trebleAvg / 255;

        const scale = 0.98 + avgNorm * 0.03 + bassNorm * 0.04;
        document.documentElement.style.setProperty('--pulse', scale.toFixed(3));

        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.18;
        const bars = 90;
        const step = Math.floor(len / bars);
        const speed = 0.0015 + trebleNorm * 0.004;
        const time = t * speed;
        const vibeColor = getVibeColor();

        ctx.strokeStyle = vibeColor;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.85;

        for (let i = 0; i < bars; i += 1) {
          const v = dataArray[i * step] / 255;
          const barLen = 14 + v * (40 + trebleNorm * 80);
          const angle = (i / bars) * Math.PI * 2 + time;
          const x1 = cx + Math.cos(angle) * radius;
          const y1 = cy + Math.sin(angle) * radius;
          const x2 = cx + Math.cos(angle) * (radius + barLen);
          const y2 = cy + Math.sin(angle) * (radius + barLen);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }

        ctx.beginPath();
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 1.5 + trebleNorm * 2;
        ctx.arc(cx, cy, radius * (1 + bassNorm * 0.06), 0, Math.PI * 2);
        ctx.stroke();

        animationId = requestAnimationFrame(animate);
      }

      window.addEventListener('resize', resizeCanvas);

      function updateVibe(tags) {
        /*
         * Professional vibe mapping: each genre maps to a
         * background gradient (--bg) and a glow colour (--glow)
         * that pulses behind the page via the body::before animation.
         */
        const vibes = {
          electronic:  { bg: 'linear-gradient(135deg, #0f0024 0%, #3a007d 40%, #7b2ff7 100%)', glow: 'radial-gradient(circle, rgba(123,47,247,0.6), transparent 70%)', color: '#a884ff' },
          chill:       { bg: 'linear-gradient(135deg, #0b1e3d 0%, #1b4f72 40%, #5dade2 100%)', glow: 'radial-gradient(circle, rgba(93,173,226,0.5), transparent 70%)', color: '#7dc8ff' },
          acoustic:    { bg: 'linear-gradient(135deg, #0a1f0a 0%, #1b5e20 40%, #4caf50 100%)', glow: 'radial-gradient(circle, rgba(76,175,80,0.45), transparent 70%)', color: '#6fd07b' },
          rock:        { bg: 'linear-gradient(135deg, #1a0000 0%, #6d0000 40%, #d32f2f 100%)', glow: 'radial-gradient(circle, rgba(211,47,47,0.5), transparent 70%)', color: '#ff5a5a' },
          pop:         { bg: 'linear-gradient(135deg, #1a0033 0%, #8e24aa 40%, #f06292 100%)', glow: 'radial-gradient(circle, rgba(240,98,146,0.5), transparent 70%)', color: '#ff8db6' },
          jazz:        { bg: 'linear-gradient(135deg, #1a1000 0%, #4e342e 40%, #d4a056 100%)', glow: 'radial-gradient(circle, rgba(212,160,86,0.45), transparent 70%)', color: '#f2c17b' },
          hiphop:      { bg: 'linear-gradient(135deg, #0d0d0d 0%, #37474f 40%, #ff6f00 100%)', glow: 'radial-gradient(circle, rgba(255,111,0,0.45), transparent 70%)', color: '#ff8f3a' },
          'hip-hop':   { bg: 'linear-gradient(135deg, #0d0d0d 0%, #37474f 40%, #ff6f00 100%)', glow: 'radial-gradient(circle, rgba(255,111,0,0.45), transparent 70%)', color: '#ff8f3a' },
          rnb:         { bg: 'linear-gradient(135deg, #120024 0%, #4a148c 40%, #ce93d8 100%)', glow: 'radial-gradient(circle, rgba(206,147,216,0.45), transparent 70%)', color: '#e0a7f2' },
          'r&b':       { bg: 'linear-gradient(135deg, #120024 0%, #4a148c 40%, #ce93d8 100%)', glow: 'radial-gradient(circle, rgba(206,147,216,0.45), transparent 70%)', color: '#e0a7f2' },
          classical:   { bg: 'linear-gradient(135deg, #0d0d1a 0%, #1a237e 40%, #9fa8da 100%)', glow: 'radial-gradient(circle, rgba(159,168,218,0.4), transparent 70%)', color: '#b8c1ff' },
          metal:       { bg: 'linear-gradient(135deg, #0a0a0a 0%, #212121 40%, #616161 100%)', glow: 'radial-gradient(circle, rgba(97,97,97,0.5), transparent 70%)', color: '#b0b0b0' },
          country:     { bg: 'linear-gradient(135deg, #1b1200 0%, #795548 40%, #ffcc80 100%)', glow: 'radial-gradient(circle, rgba(255,204,128,0.45), transparent 70%)', color: '#ffd59b' },
          soul:        { bg: 'linear-gradient(135deg, #1a0a00 0%, #bf360c 40%, #ffab91 100%)', glow: 'radial-gradient(circle, rgba(255,171,145,0.45), transparent 70%)', color: '#ffb9a3' },
          funk:        { bg: 'linear-gradient(135deg, #1a0033 0%, #6a1b9a 40%, #ffd600 100%)', glow: 'radial-gradient(circle, rgba(255,214,0,0.45), transparent 70%)', color: '#ffe263' },
          reggae:      { bg: 'linear-gradient(135deg, #0a1f0a 0%, #1b5e20 40%, #fdd835 100%)', glow: 'radial-gradient(circle, rgba(253,216,53,0.4), transparent 70%)', color: '#ffe36f' },
          blues:       { bg: 'linear-gradient(135deg, #0d1b2a 0%, #1565c0 40%, #90caf9 100%)', glow: 'radial-gradient(circle, rgba(144,202,249,0.45), transparent 70%)', color: '#a8d4ff' },
          indie:       { bg: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 40%, #e94560 100%)', glow: 'radial-gradient(circle, rgba(233,69,96,0.45), transparent 70%)', color: '#ff7b92' },
          ambient:     { bg: 'linear-gradient(135deg, #000a12 0%, #01579b 40%, #4fc3f7 100%)', glow: 'radial-gradient(circle, rgba(79,195,247,0.35), transparent 70%)', color: '#8bdcff' },
          dance:       { bg: 'linear-gradient(135deg, #0f0024 0%, #aa00ff 40%, #ea80fc 100%)', glow: 'radial-gradient(circle, rgba(234,128,252,0.5), transparent 70%)', color: '#f2a2ff' },
          latin:       { bg: 'linear-gradient(135deg, #1a0000 0%, #c62828 40%, #ffab00 100%)', glow: 'radial-gradient(circle, rgba(255,171,0,0.5), transparent 70%)', color: '#ffc04d' },
          punk:        { bg: 'linear-gradient(135deg, #0a0a0a 0%, #212121 40%, #76ff03 100%)', glow: 'radial-gradient(circle, rgba(118,255,3,0.4), transparent 70%)', color: '#b7ff5c' },
        };

        const normalized = (Array.isArray(tags) ? tags : [])
          .map(t => String(t || '').trim().toLowerCase())
          .filter(Boolean);

        let chosen = null;
        for (const t of normalized) {
          if (vibes[t]) { chosen = { tag: t, ...vibes[t] }; break; }
        }

        if (!chosen) {
          document.documentElement.style.setProperty('--bg', '#101018');
          document.documentElement.style.setProperty('--glow', 'transparent');
          document.documentElement.style.setProperty('--vibe-color', '#8aa7ff');
          tagsPill.style.display = 'none';
          tagsPill.textContent = '';
          return;
        }

        document.documentElement.style.setProperty('--bg', chosen.bg);
        document.documentElement.style.setProperty('--glow', chosen.glow);
        document.documentElement.style.setProperty('--vibe-color', chosen.color || '#8aa7ff');
        tagsPill.style.display = 'inline-block';
        tagsPill.textContent = `Top tags: ${normalized.slice(0, 3).join(', ')}`;
      }

      async function record10Seconds() {
        clearError();
        setStatus('Requesting mic…');

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const chunks = [];

        // Pick a safe mimeType if available.
        const preferred = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
        const chosenMime = preferred.find(t => window.MediaRecorder && MediaRecorder.isTypeSupported(t));

        const recorder = chosenMime ? new MediaRecorder(stream, { mimeType: chosenMime }) : new MediaRecorder(stream);

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        const stopped = new Promise((resolve) => {
          recorder.onstop = resolve;
        });

        startVisualizer(stream);
        recorder.start();
        setStatus('Recording…');

        await new Promise((r) => setTimeout(r, 10_000));
        recorder.stop();

        await stopped;
        stopVisualizer();
        stream.getTracks().forEach(t => t.stop());

        const blob = new Blob(chunks, { type: recorder.mimeType || 'audio/webm' });
        return blob;
      }

      async function identify(blob) {
        setStatus('Uploading…');

        const fd = new FormData();
        const ext = (blob.type && blob.type.includes('ogg')) ? 'ogg' : 'webm';
        fd.append('audio', blob, `recording.${ext}`);

        const resp = await fetch('/identify', { method: 'POST', body: fd });
        const payload = await resp.json().catch(() => ({}));

        if (!resp.ok) {
          const msg = payload && (payload.error || payload.message) ? JSON.stringify(payload, null, 2) : `Request failed (${resp.status})`;
          throw new Error(msg);
        }

        return payload;
      }

      function renderResult(payload) {
        const identified = payload && payload.identified ? payload.identified : null;
        if (!identified) {
          identifiedEl.textContent = '—';
        } else {
          const artist = identified.artist || 'Unknown artist';
          const title = identified.title || 'Unknown title';
          identifiedEl.textContent = `${artist} — ${title}`;
        }

        recsEl.innerHTML = '';
        const similar = payload && payload.lastfm && Array.isArray(payload.lastfm.similar_tracks) ? payload.lastfm.similar_tracks : [];
        for (const t of similar) {
          const li = document.createElement('li');
          const name = t.name || 'Unknown track';
          const artist = t.artist || 'Unknown artist';

          // Track name (linked to Last.fm if available)
          const span = document.createElement('span');
          if (t.url) {
            const a = document.createElement('a');
            a.href = t.url;
            a.target = '_blank';
            a.rel = 'noreferrer';
            a.textContent = `${artist} — ${name}`;
            span.appendChild(a);
          } else {
            span.textContent = `${artist} — ${name}`;
          }
          li.appendChild(span);

          // YouTube search link
          const ytQuery = encodeURIComponent(`${artist} - ${name}`);
          const ytLink = document.createElement('a');
          ytLink.href = `https://www.youtube.com/results?search_query=${ytQuery}`;
          ytLink.target = '_blank';
          ytLink.rel = 'noreferrer';
          ytLink.className = 'yt-link';
          ytLink.textContent = '▶ YouTube';
          li.appendChild(ytLink);

          recsEl.appendChild(li);
        }

        const tags = payload && payload.lastfm && Array.isArray(payload.lastfm.top_tags) ? payload.lastfm.top_tags : [];
        updateVibe(tags);
      }

      recordBtn.addEventListener('click', async () => {
        recordBtn.disabled = true;
        setStatus('Starting…');
        identifiedEl.textContent = '—';
        recsEl.innerHTML = '';
        tagsPill.style.display = 'none';

        try {
          const blob = await record10Seconds();
          setStatus('Identifying…');
          const payload = await identify(blob);
          renderResult(payload);
          setStatus('Done');

          // ── Seed the constellation with the identified track ──
          if (payload && payload.identified) {
            const seed = payload.identified;
            const tags = (payload.lastfm && payload.lastfm.top_tags) || [];
            const recs = (payload.lastfm && payload.lastfm.similar_tracks) || [];
            constellation.init(seed, tags, recs);
          }
        } catch (e) {
          setStatus('Error');
          showError(e && e.message ? e.message : String(e));
        } finally {
          recordBtn.disabled = false;
        }
      });

      /* ================================================================
       *  MUSIC CONSTELLATION – Force-Directed Graph on Canvas
       * ================================================================ */
      const constellation = (() => {
        const section  = document.getElementById('constellationSection');
        const wrap     = document.getElementById('constellationWrap');
        const cvs      = document.getElementById('constellationCanvas');
        const ttip     = document.getElementById('constellationTooltip');
        const gravSlider = document.getElementById('gravitySlider');
        const resetBtn   = document.getElementById('resetConstBtn');
        const cCtx     = cvs.getContext('2d');

        /* ── state ─────────────────────────────────────── */
        let nodes  = [];   // { id, artist, title, tags, playcount, x, y, vx, vy, radius, color, expanded, parent }
        let edges  = [];   // { source (id), target (id), similarity }
        let idCounter = 0;

        /* camera */
        let camX = 0, camY = 0, camScale = 1;

        /* interaction */
        let dragging  = false;
        let dragStart = { x: 0, y: 0 };
        let camStart  = { x: 0, y: 0 };
        let hoveredNode = null;
        let animId    = null;
        let loadingNodeId = null;   // node being expanded

        /* ── vibe colors (reuse the same palette) ──────── */
        const vibeColors = {
          electronic: '#a884ff', chill: '#7dc8ff', acoustic: '#6fd07b',
          rock: '#ff5a5a', pop: '#ff8db6', jazz: '#f2c17b',
          hiphop: '#ff8f3a', 'hip-hop': '#ff8f3a', rnb: '#e0a7f2',
          'r&b': '#e0a7f2', classical: '#b8c1ff', metal: '#b0b0b0',
          country: '#ffd59b', soul: '#ffb9a3', funk: '#ffe263',
          reggae: '#ffe36f', blues: '#a8d4ff', indie: '#ff7b92',
          ambient: '#8bdcff', dance: '#f2a2ff', latin: '#ffc04d',
          punk: '#b7ff5c',
        };

        function colorForTags(tags) {
          for (const t of (tags || [])) {
            const k = String(t).trim().toLowerCase();
            if (vibeColors[k]) return vibeColors[k];
          }
          return '#8aa7ff';
        }

        /* ── helpers ───────────────────────────────────── */
        function nodeById(id) { return nodes.find(n => n.id === id); }

        function radiusFromPlaycount(pc) {
          if (!pc || pc <= 0) return 8;
          // log-scale: 0 → 8,  1M → ~18,  100M → ~28
          return Math.min(32, 8 + Math.log10(pc + 1) * 2.8);
        }

        function lineLengthFromSimilarity(sim) {
          // sim ∈ [0,1]: 1→short (60), 0→long (220)
          const s = parseFloat(sim) || 0.5;
          return 220 - s * 160;
        }

        function makeId() { return ++idCounter; }

        /* ── canvas sizing ─────────────────────────────── */
        function resizeConst() {
          const r = wrap.getBoundingClientRect();
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          cvs.width  = Math.floor(r.width * dpr);
          cvs.height = Math.floor(r.height * dpr);
          cvs.style.width  = r.width + 'px';
          cvs.style.height = r.height + 'px';
          cCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        /* ── world ↔ screen ────────────────────────────── */
        function worldToScreen(wx, wy) {
          const r = wrap.getBoundingClientRect();
          return {
            x: (wx - camX) * camScale + r.width / 2,
            y: (wy - camY) * camScale + r.height / 2,
          };
        }
        function screenToWorld(sx, sy) {
          const r = wrap.getBoundingClientRect();
          return {
            x: (sx - r.width / 2)  / camScale + camX,
            y: (sy - r.height / 2) / camScale + camY,
          };
        }

        /* ── force simulation (simple Euler integration) ── */
        function simulate() {
          const gravity   = parseFloat(gravSlider.value) || 80;
          const repulsion = 6000;
          const damping   = 0.88;
          const dt        = 0.18;

          // repulsion between all nodes
          for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
              const a = nodes[i], b = nodes[j];
              let dx = b.x - a.x, dy = b.y - a.y;
              let dist = Math.sqrt(dx * dx + dy * dy) || 1;
              const force = repulsion / (dist * dist);
              const fx = (dx / dist) * force;
              const fy = (dy / dist) * force;
              a.vx -= fx * dt; a.vy -= fy * dt;
              b.vx += fx * dt; b.vy += fy * dt;
            }
          }

          // attraction along edges (spring)
          for (const e of edges) {
            const a = nodeById(e.source), b = nodeById(e.target);
            if (!a || !b) continue;
            let dx = b.x - a.x, dy = b.y - a.y;
            let dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const rest = lineLengthFromSimilarity(e.similarity);
            const stiffness = gravity / 100;          // slider controls spring stiffness
            const displacement = dist - rest;
            const fx = (dx / dist) * displacement * stiffness * dt;
            const fy = (dy / dist) * displacement * stiffness * dt;
            a.vx += fx; a.vy += fy;
            b.vx -= fx; b.vy -= fy;
          }

          // center gravity (very mild pull toward origin)
          for (const n of nodes) {
            n.vx -= n.x * 0.002 * dt;
            n.vy -= n.y * 0.002 * dt;
          }

          // integrate
          for (const n of nodes) {
            n.vx *= damping;
            n.vy *= damping;
            n.x += n.vx;
            n.y += n.vy;
          }
        }

        /* ── draw ──────────────────────────────────────── */
        function draw() {
          const r = wrap.getBoundingClientRect();
          const w = r.width, h = r.height;
          cCtx.clearRect(0, 0, w, h);

          // edges
          for (const e of edges) {
            const a = nodeById(e.source), b = nodeById(e.target);
            if (!a || !b) continue;
            const sa = worldToScreen(a.x, a.y);
            const sb = worldToScreen(b.x, b.y);
            cCtx.beginPath();
            cCtx.strokeStyle = 'rgba(255,255,255,0.12)';
            cCtx.lineWidth = 1;
            cCtx.moveTo(sa.x, sa.y);
            cCtx.lineTo(sb.x, sb.y);
            cCtx.stroke();
          }

          // nodes
          for (const n of nodes) {
            const s = worldToScreen(n.x, n.y);
            const sr = n.radius * camScale;
            if (s.x + sr < 0 || s.x - sr > w || s.y + sr < 0 || s.y - sr > h) continue; // off-screen

            // glow
            const grad = cCtx.createRadialGradient(s.x, s.y, sr * 0.4, s.x, s.y, sr * 2.2);
            grad.addColorStop(0, n.color + '66');
            grad.addColorStop(1, 'transparent');
            cCtx.fillStyle = grad;
            cCtx.beginPath();
            cCtx.arc(s.x, s.y, sr * 2.2, 0, Math.PI * 2);
            cCtx.fill();

            // disc
            cCtx.beginPath();
            cCtx.fillStyle = n.color;
            cCtx.globalAlpha = n === hoveredNode ? 1 : 0.9;
            cCtx.arc(s.x, s.y, sr, 0, Math.PI * 2);
            cCtx.fill();
            cCtx.globalAlpha = 1;

            // loading spinner ring for expanding node
            if (n.id === loadingNodeId) {
              cCtx.beginPath();
              const angle = (performance.now() / 400) % (Math.PI * 2);
              cCtx.arc(s.x, s.y, sr + 4, angle, angle + Math.PI * 1.2);
              cCtx.strokeStyle = '#fff';
              cCtx.lineWidth = 2;
              cCtx.stroke();
            }

            // label (only when zoomed in enough)
            if (camScale > 0.45 && sr > 5) {
              cCtx.fillStyle = 'rgba(255,255,255,0.8)';
              cCtx.font = `${Math.max(9, Math.round(11 * camScale))}px ui-sans-serif, system-ui, sans-serif`;
              cCtx.textAlign = 'center';
              cCtx.fillText(n.title, s.x, s.y + sr + 13);
            }
          }
        }

        /* ── animation loop ────────────────────────────── */
        function tick() {
          simulate();
          draw();
          animId = requestAnimationFrame(tick);
        }
        function startLoop() {
          if (!animId) animId = requestAnimationFrame(tick);
        }
        function stopLoop() {
          if (animId) { cancelAnimationFrame(animId); animId = null; }
        }

        /* ── camera helpers ────────────────────────────── */
        function panToNode(n, smooth) {
          camX = n.x;
          camY = n.y;
        }

        function fitAll() {
          if (!nodes.length) return;
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          for (const n of nodes) {
            minX = Math.min(minX, n.x - n.radius);
            maxX = Math.max(maxX, n.x + n.radius);
            minY = Math.min(minY, n.y - n.radius);
            maxY = Math.max(maxY, n.y + n.radius);
          }
          const r = wrap.getBoundingClientRect();
          const margin = 60;
          const scaleX = (r.width  - margin * 2) / (maxX - minX || 1);
          const scaleY = (r.height - margin * 2) / (maxY - minY || 1);
          camScale = Math.min(scaleX, scaleY, 2.5);
          camScale = Math.max(camScale, 0.15);
          camX = (minX + maxX) / 2;
          camY = (minY + maxY) / 2;
        }

        /* ── node creation ─────────────────────────────── */
        function addNode({ artist, title, tags, playcount, x, y, parent, isSeed }) {
          const nid = makeId();
          nodes.push({
            id: nid,
            artist, title, tags,
            playcount: playcount || 0,
            x: x || 0, y: y || 0,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            radius: radiusFromPlaycount(playcount),
            color: colorForTags(tags),
            expanded: false,
            parent: parent || null,
            isSeed: !!isSeed,
          });
          return nid;
        }

        function addEdge(sourceId, targetId, similarity) {
          edges.push({ source: sourceId, target: targetId, similarity: similarity || 0.5 });
        }

        /* ── helpers for deduplication ─────────────────── */
        function nodeKey(artist, title) {
          return (artist || '').trim().toLowerCase() + '\0' + (title || '').trim().toLowerCase();
        }

        function findExistingNode(artist, title) {
          const key = nodeKey(artist, title);
          return nodes.find(n => nodeKey(n.artist, n.title) === key) || null;
        }

        function edgeExists(srcId, tgtId) {
          return edges.some(e =>
            (e.source === srcId && e.target === tgtId) ||
            (e.source === tgtId && e.target === srcId)
          );
        }

        function buildExcludeList() {
          return nodes.map(n => ({ artist: n.artist, title: n.title }));
        }

        /* ── expand a node (click-to-expand) ───────────── */
        async function expandNode(node) {
          if (node.expanded || loadingNodeId) return;
          node.expanded = true;
          loadingNodeId = node.id;
          wrap.classList.add('loading');

          try {
            const resp = await fetch('/recommend', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                artist: node.artist,
                title: node.title,
                exclude: buildExcludeList(),
              }),
            });
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) return;

            const recs = (data.lastfm && data.lastfm.similar_tracks) || [];
            const newChildren = [];       // track which nodes are newly created
            const angle0 = Math.random() * Math.PI * 2;
            recs.forEach((t, i) => {
              const a = angle0 + (i / recs.length) * Math.PI * 2;
              const dist = lineLengthFromSimilarity(t.match);
              const recArtist = t.artist || 'Unknown';
              const recTitle  = t.name   || 'Unknown';

              // Check if this track already exists in the graph
              const existing = findExistingNode(recArtist, recTitle);
              if (existing) {
                // Just draw an edge to the existing node (no duplicate)
                if (!edgeExists(node.id, existing.id)) {
                  addEdge(node.id, existing.id, t.match);
                }
                return;
              }

              const nid = addNode({
                artist: recArtist,
                title: recTitle,
                tags: (data.lastfm && data.lastfm.top_tags) || [],
                playcount: 0,
                x: node.x + Math.cos(a) * dist * 0.6,
                y: node.y + Math.sin(a) * dist * 0.6,
                parent: node.id,
              });
              addEdge(node.id, nid, t.match);
              newChildren.push({ node: nodeById(nid), track: t });
            });

            // fetch playcounts in background only for NEW nodes
            newChildren.forEach(({ node: child, track: t }) => {
              if (!child) return;
              fetch('/recommend', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ artist: t.artist, title: t.name }),
              }).then(r => r.json()).then(d => {
                if (d && d.seed && d.seed.playcount) {
                  child.playcount = d.seed.playcount;
                  child.radius = radiusFromPlaycount(d.seed.playcount);
                }
                if (d && d.lastfm && d.lastfm.top_tags && d.lastfm.top_tags.length) {
                  child.tags = d.lastfm.top_tags;
                  child.color = colorForTags(child.tags);
                }
              }).catch(() => {});
            });

            // gentle auto-fit after expansion
            setTimeout(fitAll, 600);
          } finally {
            loadingNodeId = null;
            wrap.classList.remove('loading');
          }
        }

        /* ── interaction: drag-to-pan ──────────────────── */
        wrap.addEventListener('pointerdown', (e) => {
          if (e.button !== 0) return;
          dragging = true;
          dragStart = { x: e.clientX, y: e.clientY };
          camStart  = { x: camX, y: camY };
          wrap.setPointerCapture(e.pointerId);
        });
        wrap.addEventListener('pointermove', (e) => {
          const rect = wrap.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          if (dragging) {
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;
            camX = camStart.x - dx / camScale;
            camY = camStart.y - dy / camScale;
            return;
          }

          // hover detection
          const wp = screenToWorld(mx, my);
          hoveredNode = null;
          for (let i = nodes.length - 1; i >= 0; i--) {
            const n = nodes[i];
            const dx = wp.x - n.x, dy = wp.y - n.y;
            if (dx * dx + dy * dy < (n.radius + 4) * (n.radius + 4)) {
              hoveredNode = n;
              break;
            }
          }
          if (hoveredNode) {
            wrap.style.cursor = hoveredNode.expanded ? 'default' : 'pointer';
            ttip.style.display = 'block';
            ttip.textContent = `${hoveredNode.artist} — ${hoveredNode.title}${hoveredNode.playcount ? '  (' + hoveredNode.playcount.toLocaleString() + ' plays)' : ''}`;
            ttip.style.left = (mx + 14) + 'px';
            ttip.style.top  = (my - 8) + 'px';
          } else {
            wrap.style.cursor = dragging ? 'grabbing' : 'grab';
            ttip.style.display = 'none';
          }
        });
        wrap.addEventListener('pointerup', (e) => {
          if (!dragging) return;
          const dx = Math.abs(e.clientX - dragStart.x);
          const dy = Math.abs(e.clientY - dragStart.y);
          dragging = false;

          // treat as click if barely moved
          if (dx < 4 && dy < 4 && hoveredNode && !hoveredNode.expanded) {
            expandNode(hoveredNode);
          }
        });

        /* ── zoom ──────────────────────────────────────── */
        wrap.addEventListener('wheel', (e) => {
          e.preventDefault();
          const factor = e.deltaY < 0 ? 1.12 : 0.89;
          camScale = Math.max(0.08, Math.min(5, camScale * factor));
        }, { passive: false });

        /* ── gravity slider live update (no extra work, the sim reads it) ── */

        /* ── reset ─────────────────────────────────────── */
        resetBtn.addEventListener('click', () => {
          nodes = [];
          edges = [];
          idCounter = 0;
          camX = 0; camY = 0; camScale = 1;
          hoveredNode = null;
          loadingNodeId = null;
          section.classList.remove('active');
          stopLoop();
        });

        /* ── resize ────────────────────────────────────── */
        window.addEventListener('resize', () => { if (section.classList.contains('active')) resizeConst(); });

        /* ── public API ────────────────────────────────── */
        return {
          /** Called after /identify to seed the constellation. */
          init(identified, tags, recs) {
            // Reset
            nodes = []; edges = []; idCounter = 0;
            camX = 0; camY = 0; camScale = 1;
            hoveredNode = null;

            section.classList.add('active');
            resizeConst();

            // Hub node
            const hubId = addNode({
              artist: identified.artist || 'Unknown',
              title: identified.title || 'Unknown',
              tags: tags,
              playcount: identified.playcount || 0,
              x: 0, y: 0,
              isSeed: true,
            });
            const hub = nodeById(hubId);
            hub.expanded = true;     // it already has children

            // Child nodes
            const angle0 = Math.random() * Math.PI * 2;
            recs.forEach((t, i) => {
              const a = angle0 + (i / recs.length) * Math.PI * 2;
              const dist = lineLengthFromSimilarity(t.match);
              const nid = addNode({
                artist: t.artist || 'Unknown',
                title: t.name || 'Unknown',
                tags: tags,            // inherit parent tags initially
                playcount: 0,
                x: Math.cos(a) * dist * 0.6,
                y: Math.sin(a) * dist * 0.6,
                parent: hubId,
              });
              addEdge(hubId, nid, t.match);
            });

            // Fetch individual playcounts + tags in background
            recs.forEach((t, i) => {
              const child = nodes[1 + i];
              if (!child) return;
              fetch('/recommend', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ artist: t.artist, title: t.name }),
              }).then(r => r.json()).then(d => {
                if (d && d.seed && d.seed.playcount) {
                  child.playcount = d.seed.playcount;
                  child.radius = radiusFromPlaycount(d.seed.playcount);
                }
                if (d && d.lastfm && d.lastfm.top_tags && d.lastfm.top_tags.length) {
                  child.tags = d.lastfm.top_tags;
                  child.color = colorForTags(child.tags);
                }
              }).catch(() => {});
            });

            startLoop();
            fitAll();
          },
        };
      })();
    </script>
  </body>
</html>
